/**
 * Mule LDAP Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */

package org.mule.module.ldap;

import java.net.UnknownHostException;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Transformer;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.module.ldap.ldap.api.AuthenticationException;
import org.mule.module.ldap.ldap.api.CommunicationException;
import org.mule.module.ldap.ldap.api.LDAPConnection;
import org.mule.module.ldap.ldap.api.LDAPEntry;
import org.mule.module.ldap.ldap.api.LDAPException;
import org.mule.module.ldap.ldap.api.LDAPResultSet;
import org.mule.module.ldap.ldap.api.LDAPSearchControls;
import org.mule.module.ldap.ldap.api.NameNotFoundException;

/**
 * Cloud Connector
 * 
 * @author Mariano Capurro (MuleSoft, Inc.)
 */
@Connector(name = "ldap", schemaVersion = "3.2")
public class LDAPConnector
{
    private static final Logger LOGGER = Logger.getLogger(LDAPConnector.class);
    
    /**
     * Configurable url
     */
    @Configurable
    private String url;

    /**
     * Type
     */
    @Configurable
    @Optional
    @Default(value = "JNDI")
    private Type type;

    /**
     * Authentication
     */
    @Configurable
    @Optional
    @Default(value = "none")
    private String authentication;

    /**
     * Initial Pool Size
     */
    @Configurable
    @Optional
    @Default(value = "1")
    private int initialPoolSize;

    /**
     * Max Pool Size
     */
    @Configurable
    @Optional
    @Default(value = "5")
    private int maxPoolSize;

    /**
     * Pool Timeout
     */
    @Configurable
    @Optional
    @Default(value = "60000")
    private long poolTimeout;

    /**
     * Referral
     */
    @Configurable
    @Optional
    @Default(value = "IGNORE")
    private Referral referral;
    
    /**
     * Extended Configuration
     */
    @Configurable
    @Optional
    private Map<String, String> extendedConfiguration;
    
    private LDAPConnection connection = null;
    
    /**
     * Connect
     * 
     * @param authDn A authDn
     * @param authPassword A authPassword
     * @throws ConnectionException
     */
    @Connect
    public void connect(@ConnectionKey @Default(value = "ANONYMOUS") String authDn, @Default(value = "ANONYMOUS") String authPassword) throws ConnectionException
    {
        /*
         * DevKit doesn't support null values for the @Connect parameters. The default ANONYMOUS value is used internally for these cases.
         * ANONYMOUS is not a valid DN so it is used for this purpose as a keyword to indicate that the bind should be performed in this way. 
         */
        try
        {
            if(this.connection == null)
            {
                this.connection = LDAPConnection.getConnection(type.toString(), getUrl(), getAuthentication(), getInitialPoolSize(), getMaxPoolSize(), getPoolTimeout(), getReferral().toString(), getExtendedConfiguration());
            }
            // Turning anonymous keywords to actual bind values (null DN means anonymous bin)
            String dn = "ANONYMOUS".equals(authDn) ? null : authDn;
            String password = "ANONYMOUS".equals(authDn) && "ANONYMOUS".equals(authPassword) ? null : authPassword;
            
            this.connection.bind(dn, password);
        }
        catch(CommunicationException ex)
        {
            if(ex.getCause() instanceof javax.naming.CommunicationException && ((javax.naming.CommunicationException) ex.getCause()).getRootCause() instanceof UnknownHostException)
            {
                throw new ConnectionException(ConnectionExceptionCode.UNKNOWN_HOST, ex.getCode(), ex.getMessage(), ex);
            }
            else
            {
                throw new ConnectionException(ConnectionExceptionCode.CANNOT_REACH, ex.getCode(), ex.getMessage(), ex);
            }
        }
        catch(AuthenticationException ex)
        {
            throw new ConnectionException(ConnectionExceptionCode.INCORRECT_CREDENTIALS, ex.getCode(), ex.getMessage(), ex);
        }
        catch(NameNotFoundException ex)
        {
            throw new ConnectionException(ConnectionExceptionCode.INCORRECT_CREDENTIALS, ex.getCode(), ex.getMessage(), ex);
        }
        catch(LDAPException ex)
        {
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, ex.getCode(), ex.getMessage(), ex);
        }
        catch(Throwable ex)
        {
            throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, ex.getMessage(), ex);
        }
    }

    /**
     * Disconnect
     * @throws LDAPException 
     */
    @Disconnect
    public void disconnect() throws LDAPException
    {
        if (this.connection != null)
        {
            try
            {
                this.connection.close();
            }
            catch (LDAPException ex)
            {
                LOGGER.error("Unable to close connection to LDAP", ex);
                throw ex;
            }
            finally
            {
                this.connection = null;
            }
        }
    }

    /**
     * Are we connected
     * 
     * @return boolean
     */
    @ValidateConnection
    public boolean isConnected() throws LDAPException
    {
        try
        {
            return this.connection != null && !this.connection.isClosed();
        }
        catch (LDAPException ex)
        {
            LOGGER.error("Unable to validate LDAP connection", ex);
            throw ex;
        }        
    }

    /**
     * Are we connected
     * 
     * @return String with the connection Id
     */
    @ConnectionIdentifier
    public String connectionId()
    {
        return this.connection != null ? this.connection.toString() : "null connection";
    }

    /**
     * Retrieves an entry from the LDAP server
     * 
     * {@sample.xml ../../../doc/LDAP-connector.xml.sample ldap:lookup}
     * 
     * @param dn The dn.
     * @param attributes A list of attributes.
     * @return a {@link LDAPEntry}
     * 
     * @throws Exception
     */
    @Processor
    public LDAPEntry lookup(String dn, @Optional List<String> attributes) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("About to retrieve LDAP entry: " + dn);
        }
        
        LDAPEntry entry = null;
        if(attributes != null && attributes.size() > 0)
        {
            entry = this.connection.lookup(dn, attributes.toArray(new String[0]));
        }
        else
        {
            entry = this.connection.lookup(dn);
        }
        
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("Retrieved entry: " + entry);
        }
        
        return entry;
    }
    
    /**
     * Searches some specifics entries from the LDAP server.
     * 
     * {@sample.xml ../../../doc/LDAP-connector.xml.sample ldap:search}
     * 
     * @param baseDn The base Dn
     * @param filter A filter.
     * @param attributes A list of attributes
     * @param scope The Search Scope
     * @param timeout Timeout
     * @param maxResults Max Results
     * @param returnObject Boolean to set the returnObject
     * @return a list of {@link LDAPEntry}
     * @throws Exception
     */
    @Processor
    public List<LDAPEntry> search(String baseDn, String filter, @Optional List<String> attributes, @Optional @Default("ONE_LEVEL") SearchScope scope, @Optional @Default("0") int timeout, @Optional @Default("0") long maxResults, @Optional @Default("false") boolean returnObject) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("About to search LDAP entries matching " + filter + " under: " + baseDn);
        }
        
        LDAPResultSet result = null;
        LDAPSearchControls controls = new LDAPSearchControls();
        if(attributes != null && attributes.size() > 0)
        {
            controls.setAttributesToReturn(attributes.toArray(new String[0]));
        }
        controls.setMaxResults(maxResults);
        controls.setTimeout(timeout);
        controls.setScope(scope.getValue());
        controls.setReturnObject(returnObject);
        
        result = this.connection.search(baseDn, filter, controls);
        
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("Retrieved " + result.getEntries().size() + " entries");
        }
        
        return result.getEntries();        
    }
    
    /**
     * Searches for one entry from the LDAP server.
     * 
     * {@sample.xml ../../../doc/LDAP-connector.xml.sample ldap:search-one}
     * 
     * @param baseDn The base Dn
     * @param filter A filter
     * @param attributes A list of attributes
     * @param scope The Search Scope
     * @param timeout Timeout
     * @param maxResults MaxResults
     * @param returnObject Boolean to set the returnObject
     * @return a {@link LDAPEntry}
     * @throws Exception
     */
    @Processor
    public LDAPEntry searchOne(String baseDn, String filter, @Optional List<String> attributes, @Optional @Default("ONE_LEVEL") SearchScope scope, @Optional @Default("0") int timeout, @Optional @Default("0") long maxResults, @Optional @Default("false") boolean returnObject) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("Searching entries under " + baseDn + " with filter " + filter);
        }
        
        List<LDAPEntry> results = search(baseDn, filter, attributes, scope, timeout, maxResults, returnObject);
        
        if(results != null && results.size() > 1)
        {
            LOGGER.warn("Search returned more than one result. Total results matching filter [" + filter + "]: " + results.size());
        }
        
        return results != null && results.size() > 0 ? results.get(0) : null;
    }

    /**
     * 
     * @param dn
     * @param attributes
     * @throws Exception
     */
    @Processor
    public void create(String dn, @Optional @Default("#[payload:]") Map<String, String> attributes) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("About to create entry " + dn + ": " + attributes);
        }        
        
        this.connection.addEntry(new LDAPEntry(dn, attributes));
        
        if(LOGGER.isInfoEnabled())
        {
            LOGGER.info("Created entry " + dn);
        }
    }
    
    /**
     * 
     * @param entry
     * @throws Exception
     */
    @Processor
    public void createEntry(@Optional @Default("#[payload:]") LDAPEntry entry) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("About to create entry " + entry.getDn() + ": " + entry);
        }        
        
        this.connection.addEntry(entry);
        
        if(LOGGER.isInfoEnabled())
        {
            LOGGER.info("Created entry " + entry.getDn());
        }
    }
    
    @Transformer(sourceTypes = {Map.class})
    public static LDAPEntry mapToLdapEntry(Map<String, Object> entry) throws Exception
    {
        if(LOGGER.isDebugEnabled())
        {
            LOGGER.debug("About to transform map " + entry);
        }         
        return new LDAPEntry(entry);
    }

    @Transformer(sourceTypes = {LDAPEntry.class})
    public static Map<String, Object> ldapEntryToMap(LDAPEntry entry)
    {
        return entry != null ? entry.toMap() : null;
    }
    
    @Transformer(sourceTypes = {LDAPEntry.class})
    public static String ldapEntryToLdif(LDAPEntry entry)
    {
        return entry != null ? entry.toLDIFString() : null;
    }

    public String getUrl()
    {
        return url;
    }

    public void setUrl(String url)
    {
        this.url = url;
    }

    public Type getType()
    {
        return type;
    }

    public void setType(Type type)
    {
        this.type = type;
    }

    public String getAuthentication()
    {
        return authentication;
    }

    public void setAuthentication(String authentication)
    {
        this.authentication = authentication;
    }

    public int getInitialPoolSize()
    {
        return initialPoolSize;
    }

    public void setInitialPoolSize(int initialPoolSize)
    {
        this.initialPoolSize = initialPoolSize;
    }

    public int getMaxPoolSize()
    {
        return maxPoolSize;
    }

    public void setMaxPoolSize(int maxPoolSize)
    {
        this.maxPoolSize = maxPoolSize;
    }

    public long getPoolTimeout()
    {
        return poolTimeout;
    }

    public void setPoolTimeout(long poolTimeout)
    {
        this.poolTimeout = poolTimeout;
    }

    public Referral getReferral()
    {
        return referral;
    }

    public void setReferral(Referral referral)
    {
        this.referral = referral;
    }

    public Map<String, String> getExtendedConfiguration()
    {
        return extendedConfiguration;
    }

    public void setExtendedConfiguration(Map<String, String> extendedConfiguration)
    {
        this.extendedConfiguration = extendedConfiguration;
    }
}
